import http.client
import json
import ssl
import os
import Endpoints as ep
from configparser import ConfigParser

"""
ChiaStatusClient
    Performs a synchronous request against the chia blockchain given a dict containing the endpoint and port.
    Returns a dict containing the response of the endpoint.

    The client uses the key generated by your wallet, which is already set up in the config.ini file. Please update
    the config.ini if the key location is different.
"""
class ChiaStatusClient:
    def __init__(self) -> None:
        config = ConfigParser()
        config.read('config.ini')

        try:
            cert = config.get("chiaclient", "cert_file")
            key = config.get("chiaclient", "key_file")
        except:
            print("Missing cert_file or key_file in config.ini. Please ensure these keys are available under [chiaclient]")
            exit()
        
        self.cert_file = os.path.expanduser(cert)
        self.key_file = os.path.expanduser(key)
        self.host = "localhost"
        self.headers = {"Content-Type": "application/json"}
        self.ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        try:
            self.ctx.load_cert_chain(certfile=self.cert_file, keyfile=self.key_file)
        except:
            print("Could not load certificate or key file. Check the path in config.ini and try again")
            print("cert_file=" + self.cert_file)
            print("key_file=" + self.key_file)
            exit()

    def req(self, req_loc: ep.Endpoint, body = {}) -> dict:
        if req_loc == None:
            return {"error": "Could not determine endpoint"}

        conn = http.client.HTTPSConnection(host=self.host, port=req_loc.port, context=self.ctx)
        conn.request("POST", url=req_loc.endpoint, headers=self.headers, body=json.dumps(body))

        resp = conn.getresponse()

        if resp.status != 200:
            return {"error": str(resp.status) + " " + resp.reason}

        data = resp.read()
        """
        Unfortunately, the API I am sending data to does not like big numbers. I'm taking the easy way out here and
        parsing all the floats and ints I find as a string
        """
        return json.loads(data, parse_float=str, parse_int=str)