import http.client
import json
import ssl
import os
from configparser import ConfigParser

"""
ChiaStatusClient
    Performs a synchronous request against the chia blockchain given a dict containing the endpoint and port.
    Returns a dict containing the response of the endpoint.

    The client uses the key generated by your wallet, which is already set up in the config.ini file. Please update
    the config.ini if the key location is different.

Reference https://github.com/Chia-Network/chia-blockchain/wiki/RPC-Interfaces
    DAEMON = 55400
    FULL_NODE = 8555
    FARMER = 8559
    HARVESTER = 8560
    WALLET =  9256

"""
class ChiaStatusClient:
    def __init__(self) -> None:
        config = ConfigParser()
        cl = config.read('config.ini')

        if cl.__len__() == 0:
            print("Could not open config.ini. Please ensure it exists in the same directory as the main program.")
            exit()
        
        try:
            cert = config.get("chiaclient", "cert_file")
            key = config.get("chiaclient", "key_file")
        except:
            print("Missing cert_file or key_file in config.ini. Please ensure these keys are available under [chiaclient]")
            exit()
        
        self.cert_file = os.path.expanduser(cert)
        self.key_file = os.path.expanduser(key)
        self.host = "localhost"
        self.headers = {"Content-Type": "application/json"}
        self.ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        try:
            self.ctx.load_cert_chain(certfile=self.cert_file, keyfile=self.key_file)
        except:
            print("Could not load certificate or key file. Check the path in config.ini and try again")
            print("cert_file=" + self.cert_file)
            print("key_file=" + self.key_file)
            exit()

    def send(self, endpoint: str, port: int, body = {}) -> dict:
        if endpoint == None:
            return {"error": "Could not determine endpoint"}
        try:
            conn = http.client.HTTPSConnection(host=self.host, port=port, context=self.ctx)
            conn.request("POST", url=endpoint, headers=self.headers, body=json.dumps(body))
            resp = conn.getresponse()
        except:
            return {"error": "Could not connect"}

        if resp.status != 200:
            return {"error": str(resp.status) + " " + resp.reason}

        data = resp.read()
        """
        Unfortunately, the API I am sending data to does not like big numbers. I'm taking the easy way out here and
        parsing all the floats and ints I find as a string
        """
        return json.loads(data, parse_float=str, parse_int=str)